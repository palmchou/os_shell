//
// Created by Palm on 22/05/15.
//

#include "job_control.h"

void signal_handler(int sig) {
    if (sig == SIGINT) {
        //puts("zsh SIGINT received.");
        printf("\n");
        if (current_job == NULL)
            printPrompt();
        else {
            kill(current_job->pid, SIGINT);
        }
    } else if (sig == SIGTSTP) {
        //printf("SIGTSTP received.");
        printf("\n");
        if (current_job == NULL) {
            printf("\a");
            printPrompt();
        } else {
            kill(current_job->pid, SIGTSTP);
            current_job->runSTAT = STOPED;
            current_job->groundType = BG;
            print_job_info(current_job);
        }
    } else if (sig == SIGCHLD) {
        int status, pid;
        while (1) {

            /* retrieve child process ID (if any) */
            pid = waitpid(-1, &status, WNOHANG);

            /* check for conditions causing the loop to terminate */
            if (pid == -1) {
                /* continue on interruption (EINTR) */
                if (errno == EINTR) {
                    continue;
                }
                /* break on anything else (EINVAL or ECHILD according to manpage) */
                break;
            }
            else if (pid == 0) {
                /* no more children to process, so break */
                break;
            }

            /* valid child process ID retrieved, process accordingly */
            if (!WIFSTOPPED(status)) {
                Job* job = find_job_for(pid);
                if (job->groundType == BG)
                    printf("\n[%d]\t%7s\t%25s\n", job->jid, "done", job->job_command);
                reset_job_position(job);
                if (WIFEXITED(status)) {
                    last_running_status = WEXITSTATUS(status);
                }
            }
        }
    }
}
void init_job_control() {
    signal(SIGINT, signal_handler);
    signal(SIGTSTP, signal_handler);
    signal(SIGCHLD, signal_handler);
    Jobs_table = (Job*)calloc(MAX_JOBS_NUM, sizeof(Job));
    memset(Jobs_table, 0, MAX_JOBS_NUM * sizeof(Job));
    current_job = NULL;
}

unsigned getLeastAvailableJID() {
    unsigned i;
    for (i = 1; i < MAX_JOBS_NUM; i++) {
        if (Jobs_table[i].active == 0)
            return i;
    }
    // all the jobs are occupied.
    quit(10);
    exit(10);
}

void reset_job_position(Job* job) {
    if (job != NULL) {
        if (job->job_command != NULL)
            free(job->job_command);
        job->job_command = NULL;
        job->groundType = (GroundType)0;
        job->runSTAT = (RunSTAT)0;
        job->pid = 0;
        job->active = 0;
    }
}

void print_job_info(Job* job) {
    char* status;
    // the cast here is used to suppress warning generated by IDE
    status = (job->runSTAT == STOPED) ? "Stoped" : "Running";
    printf("[%d]\t%7s\t%25s\n", job->jid, status, job->job_command);
}

Job* find_job_for(int pid) {
    int i;
    Job* job;
    for (i = 1; i < MAX_JOBS_NUM; i++) {
        job = Jobs_table + i;
        if (job->pid == pid) {
            return job;
        }
    }
    return NULL;
}